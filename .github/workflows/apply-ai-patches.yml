name: Apply AI patches

on:
  issue_comment:
    types: [created]

concurrency:
  group: apply-ai-${{ github.event.issue.number }}
  cancel-in-progress: false  # Changed: Don't cancel to allow completion

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  apply_patch:
    runs-on: ubuntu-latest
    # Enhanced trigger: Check for resolved: blocks specifically  
    if: >
      github.event.issue.pull_request != null &&
      (contains(github.event.comment.body, 'resolved:') || contains(github.event.comment.body, '/apply-patches-now'))
    
    steps:
      - name: Get PR info
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = (await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            })).data;
            core.setOutput('number', pr.number);
            core.setOutput('ref', pr.head.ref);
            core.setOutput('repo', pr.head.repo.full_name);
            core.setOutput('sha', pr.head.sha);
            core.setOutput('mergeable', pr.mergeable);
            core.setOutput('mergeable_state', pr.mergeable_state);

      - name: Checkout PR head branch (bullet-proof)
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ github.event.issue.number }}/head
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "ai-fixer-bot"
          git config user.email "ai-fixer-bot@users.noreply.github.com"

      - name: Collect all resolved files from comments
        id: collect
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;
            
            // Get all comments on this PR
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number
            });
            
            // Find all resolved: blocks from any comment
            const resolvedFiles = new Map();
            const resolvedPattern = /```resolved:([^\n`]+)\n(.*?)\n```/gs;
            
            for (const comment of comments) {
              let match;
              while ((match = resolvedPattern.exec(comment.body)) !== null) {
                const filePath = match[1].trim();
                const content = match[2];
                resolvedFiles.set(filePath, content);
                console.log(`Found resolved file: ${filePath}`);
              }
            }
            
            // Save to files for processing
            const fs = require('fs');
            const resolvedData = Object.fromEntries(resolvedFiles);
            fs.writeFileSync('/tmp/resolved_files.json', JSON.stringify(resolvedData, null, 2));
            
            core.setOutput('count', resolvedFiles.size);
            core.setOutput('files', Array.from(resolvedFiles.keys()).join(','));
            
            return resolvedData;

      - name: Apply resolved files
        id: apply
        run: |
          if [ ! -f /tmp/resolved_files.json ]; then
            echo "No resolved files found"
            echo "applied=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          python - <<'PY'
          import json, pathlib, subprocess, sys
          
          def sh(cmd):
              print(f'+ {cmd}')
              return subprocess.run(cmd, shell=True, check=False, capture_output=True, text=True)
          
          # Load resolved files
          resolved_data = json.loads(pathlib.Path('/tmp/resolved_files.json').read_text())
          applied = 0
          
          for file_path, content in resolved_data.items():
              print(f"Applying resolved file: {file_path}")
              
              # Create directories if needed
              p = pathlib.Path(file_path)
              p.parent.mkdir(parents=True, exist_ok=True)
              
              # Write the resolved content
              p.write_text(content, encoding='utf-8')
              
              # Stage the file
              sh(f"git add '{file_path}'")
              applied += 1
              
          print(f"Applied {applied} resolved files")
          
          # Save count for later steps
          with open('/tmp/applied_count.txt', 'w') as f:
              f.write(str(applied))
          PY
          
          echo "applied=$(cat /tmp/applied_count.txt)" >> $GITHUB_OUTPUT

      - name: Check remaining conflicts after applying patches
        id: conflicts
        run: |
          git fetch origin main
          # Reset to clean state and try merge with applied files
          git reset --hard HEAD
          git merge --no-commit --no-ff origin/main || true
          
          # Apply the resolved files again after merge attempt
          if [ -f /tmp/resolved_files.json ]; then
            python - <<'PY'
          import json, pathlib
          resolved_data = json.loads(pathlib.Path('/tmp/resolved_files.json').read_text())
          for file_path, content in resolved_data.items():
              pathlib.Path(file_path).write_text(content, encoding='utf-8')
          PY
          fi
          
          git add -A
          
          # Check if any conflicts remain
          if git ls-files -u | grep -q .; then
            echo "has_conflicts=true" >> $GITHUB_OUTPUT
            git ls-files -u | cut -f2 | sort -u > /tmp/remaining_conflicts
            echo "remaining=$(cat /tmp/remaining_conflicts | tr '\n' ',' | sed 's/,$//')" >> $GITHUB_OUTPUT
          else
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
            echo "remaining=" >> $GITHUB_OUTPUT
          fi

      - name: Sanity check - no conflict markers remain in resolved files
        run: |
          if git grep -n "<<<<<<<" -- . ':!.github/workflows/*' ':!tmp/*'; then
            echo "ERROR: Conflict markers still present in files!"
            git grep -n "<<<<<<<" -- . ':!.github/workflows/*' ':!tmp/*'
            
            # Don't fail completely - just warn
            echo "‚ö†Ô∏è Conflict markers detected - may need manual review"
          fi

      - name: Format & quick compile check
        run: |
          python -m pip install -q black isort 2>/dev/null || true
          black . 2>/dev/null || true
          isort . 2>/dev/null || true
          git add -A
          python -m compileall -q . || true

      - name: Commit & push changes
        id: commit
        run: |
          if ! git diff --cached --quiet; then
            applied_count=$(cat /tmp/applied_count.txt || echo "0")
            
            # Commit the resolution
            git commit -m "AI: Apply resolved files for conflict resolution

Applied $applied_count resolved files from AI agent
Triggered by comment from ${{ github.event.comment.user.login }}"
            
            # Push with force-with-lease for safety
            git push --force-with-lease origin HEAD:${{ steps.pr.outputs.ref }}
            echo "pushed=true" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit"
            echo "pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: Update PR status and labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;
            const pushed = '${{ steps.commit.outputs.pushed }}' === 'true';
            const appliedCount = '${{ steps.apply.outputs.applied }}';
            const hasConflicts = '${{ steps.conflicts.outputs.has_conflicts }}' === 'true';
            const remainingFiles = '${{ steps.conflicts.outputs.remaining }}'.split(',').filter(f => f);
            
            if (pushed) {
              // Add success reaction
              await github.rest.reactions.createForIssueComment({
                owner, repo,
                comment_id: context.payload.comment.id,
                content: 'rocket'
              });
              
              if (!hasConflicts) {
                // All conflicts resolved!
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: '‚úÖ **Successfully applied AI patches and resolved ALL conflicts!**\n\n' +
                        `Applied ${appliedCount} resolved files. The PR should now be ready for merge.`
                });
                
                // Remove conflict-related labels
                const labelsToRemove = ['needs-merge-help', 'auto-conflict'];
                for (const label of labelsToRemove) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner, repo, issue_number, name: label
                    });
                  } catch (e) {
                    // Label might not exist, that's OK
                  }
                }
              } else {
                // Partial resolution
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: 'üîÑ **Partially applied AI patches**\n\n' +
                        `Applied ${appliedCount} resolved files, but conflicts remain in:\n` +
                        remainingFiles.map(f => `- \`${f}\``).join('\n') + '\n\n' +
                        'The AI agent needs to provide additional resolved: blocks for the remaining files.'
                });
              }
            } else {
              // No changes made
              await github.rest.reactions.createForIssueComment({
                owner, repo,
                comment_id: context.payload.comment.id,
                content: 'confused'
              });
              
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: '‚ö†Ô∏è **No changes applied from AI patches**\n\n' +
                      'This could mean:\n' +
                      '- No valid `resolved:` blocks found in recent comments\n' +
                      '- The files were already resolved\n' +
                      '- The comment format was incorrect\n\n' +
                      'Make sure each resolution uses the format:\n' +
                      '```resolved:path/to/file.py\n[complete file content]\n```'
              });
            }