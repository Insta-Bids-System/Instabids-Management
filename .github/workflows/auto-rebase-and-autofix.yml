name: Auto-rebase PRs and autofix trivial conflicts

on:
  push:
    branches: [ main ]
  pull_request:
    types: [opened, synchronize, reopened]
  schedule:
    - cron: "*/20 * * * *"
  issue_comment:
    types: [created]
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  CODEX_HANDLE: "@codex"

jobs:
  collect:
    if: github.event_name != 'issue_comment'
    runs-on: ubuntu-latest
    outputs:
      prs: ${{ steps.out.outputs.prs }}
    steps:
      - id: out
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const all = await github.paginate(
              github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 }
            );
            const target = all
              .filter(pr => pr.base.ref === 'main' && pr.head.repo.full_name === `${owner}/${repo}`)
              .map(pr => ({ number: pr.number, ref: pr.head.ref, repo: pr.head.repo.full_name }));
            core.setOutput('prs', JSON.stringify(target));

  update:
    if: github.event_name != 'issue_comment' && fromJSON(needs.collect.outputs.prs).length > 0
    needs: collect
    runs-on: ubuntu-latest
    strategy:
      matrix:
        pr: ${{ fromJSON(needs.collect.outputs.prs) }}
      max-parallel: 3
    steps:
      - name: Checkout PR head branch
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.pr.repo }}
          ref: ${{ matrix.pr.ref }}
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Bot identity & rerere
        run: |
          git config user.name  "autorebase-bot"
          git config user.email "autorebase-bot@users.noreply.github.com"
          git config rerere.enabled true
          git remote add upstream "https://github.com/${{ github.repository }}.git"
          git fetch upstream main

      - name: Rebase onto latest main (continue on conflicts)
        run: git rebase upstream/main || true

      - name: Autofix common conflicts
        run: |
          python - <<'PY'
          import re, subprocess, pathlib
          sh=lambda c: subprocess.run(c, shell=True, check=False)
          fixed_files = []
          
          # Markdown: union (drop markers)
          for p in pathlib.Path('.').rglob('*.md'):
              t=p.read_text(errors='ignore')
              if '<<<<<<<' in t and '>>>>>>>' in t:
                  t=re.sub(r'^<<<<<<< .*?\n|^=======\n|^>>>>>>> .*?\n','',t,flags=re.M)
                  p.write_text(t); sh(f"git add {p}")
                  fixed_files.append(str(p))
                  print(f"AUTO-FIXED (markdown union): {p}")
          
          # Lockfiles: prefer ours
          for n in ['package-lock.json','yarn.lock','pnpm-lock.yaml','poetry.lock']:
              p=pathlib.Path(n)
              if p.exists() and sh(f"git ls-files -u {n}").returncode == 0: 
                  sh(f"git checkout --ours {n} && git add {n}")
                  fixed_files.append(n)
                  print(f"AUTO-FIXED (lockfile): {n}")
          
          # Python: union/dedupe imports, dedupe include_router blocks
          CON=re.compile(r"<<<<<<< .*?\n(.*?)\n=======\n(.*?)\n>>>>>>> .*?\n", re.S)
          def dedupe(xs):
              out=[]; seen=set()
              for x in xs:
                  if x not in seen:
                      out.append(x); seen.add(x)
              return out
          def merge(a,b):
              A=[l.rstrip() for l in a.strip().splitlines()]
              B=[l.rstrip() for l in b.strip().splitlines()]
              if ''.join(A)==''.join(B):
                  return '\n'.join(A)+'\n'
              if all(l.startswith(('import ','from ')) or l=='' for l in A+B):
                  imp=dedupe([*A,*B]); imp=[l for l in imp if l]; imp.sort()
                  return '\n'.join(imp)+'\n'
              if 'app.include_router' in '\n'.join([*A,*B]):
                  def blocks(L):
                      buf=[]; out=[]
                      for l in L+['']:
                          buf.append(l)
                          if l.strip().startswith(')') or l.strip()=='':
                              ch='\n'.join(buf).strip()
                              if 'app.include_router' in ch: out.append(ch)
                              buf=[]
                      return out
                  m=dedupe(blocks(A)+blocks(B))
                  if m: return '\n\n'.join(m)+'\n'
              if len(A)<=10 and len(B)<=10:
                  return '\n'.join(dedupe(A+B))+'\n'
              return None
          for p in pathlib.Path('.').rglob('*.py'):
              t=p.read_text(errors='ignore')
              if '<<<<<<<' in t and '>>>>>>>' in t:
                  def repl(m):
                      r=merge(m.group(1), m.group(2))
                      return m.group(0) if r is None else r
                  new=CON.sub(repl,t)
                  if new!=t:
                      p.write_text(new); sh(f"git add {p}")
                      fixed_files.append(str(p))
                      print(f"AUTO-FIXED (python imports/routers): {p}")
          
          if fixed_files:
              print(f"\n‚úÖ Auto-fixed {len(fixed_files)} file(s):")
              for f in fixed_files:
                  print(f"  - {f}")
          PY

      - name: Continue rebase if possible
        run: git -c core.editor=true rebase --continue || true

      - name: Check remaining conflicts
        id: conf
        run: |
          git ls-files -u | cut -f2 | sort -u > /tmp/conflicts || true
          echo "Files still in conflict:"
          cat /tmp/conflicts || true
          echo "count=$(wc -l < /tmp/conflicts | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Format (normalize diffs)
        if: steps.conf.outputs.count == '0'
        run: |
          python -m pip install --upgrade pip >/dev/null 2>&1 || true
          pip install black isort >/dev/null 2>&1 || true
          isort . || true
          black . || true
          git add -A

      - name: Commit & push if clean
        if: steps.conf.outputs.count == '0'
        run: |
          if ! git diff --cached --quiet; then
            git commit -m "auto-rebase on main (+safe conflict resolves)"
          fi
          git push --force-with-lease origin HEAD:${{ matrix.pr.ref }}

      - name: Generate per-file conflict comments with COMPLETE files
        if: steps.conf.outputs.count != '0'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ matrix.pr.number }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const files = fs.readFileSync('/tmp/conflicts','utf8').trim().split('\n').filter(Boolean);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prnum = Number(process.env.PR_NUMBER);
            
            await github.rest.issues.addLabels({ 
              owner, repo, issue_number: prnum, 
              labels: ['codex','needs-merge-help','auto-conflict'] 
            }).catch(()=>{});
            
            console.log(`üîç Detected ${files.length} conflicted files: ${files.join(', ')}`);
            
            // Post COMPLETE file content for each conflicted file
            for (const file of files) {
              try {
                console.log(`üìñ Processing: ${file}`);
                let content = '';
                let readMethod = 'unknown';
                
                // Method 1: Try direct read first (works if file exists with markers)
                try {
                  content = fs.readFileSync(file, 'utf8');
                  readMethod = 'direct fs.readFileSync';
                  console.log(`‚úÖ Read via direct fs.readFileSync`);
                } catch (fsErr) {
                  console.log(`‚ö†Ô∏è Direct read failed: ${fsErr.message}`);
                  
                  // Method 2: Use cat command to force read
                  try {
                    content = execSync(`cat "${file}" 2>/dev/null || echo "FILE_NOT_FOUND"`, 
                                     { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                    if (content === 'FILE_NOT_FOUND\n') {
                      throw new Error('File not found via cat');
                    }
                    readMethod = 'cat command';
                    console.log(`‚úÖ Read via cat command`);
                  } catch (catErr) {
                    console.log(`‚ö†Ô∏è Cat failed: ${catErr.message}`);
                    
                    // Method 3: Try git show for working tree
                    try {
                      content = execSync(`git show ":${file}" 2>/dev/null || echo "GIT_SHOW_FAILED"`, 
                                       { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                      if (content === 'GIT_SHOW_FAILED\n') {
                        throw new Error('Git show failed');
                      }
                      readMethod = 'git show';
                      console.log(`‚úÖ Read via git show`);
                    } catch (gitErr) {
                      console.log(`‚ö†Ô∏è Git show failed: ${gitErr.message}`);
                      
                      // Method 4: Get diff as last resort
                      try {
                        const diff = execSync(`git diff "${file}"`, 
                                            { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                        content = `[Could not read full file - showing diff]\n\n${diff}`;
                        readMethod = 'git diff (fallback)';
                        console.log(`‚ö†Ô∏è Using git diff as fallback`);
                      } catch (diffErr) {
                        content = `ERROR: Unable to read file using any method\nTried: direct read, cat, git show, git diff\nLast error: ${diffErr.message}`;
                        readMethod = 'all methods failed';
                        console.log(`‚ùå All read methods failed`);
                      }
                    }
                  }
                }
                
                const hasMarkers = content.includes('<<<<<<<') && content.includes('>>>>>>>');
                console.log(`üìä File size: ${content.length} bytes, has conflict markers: ${hasMarkers}, read method: ${readMethod}`);
                
                const header = `## üîß Conflict in: \`${file}\`\n\n` +
                              `${process.env.CODEX_HANDLE} - This file has merge conflicts that need resolution.\n` +
                              `Read method: ${readMethod}\n\n`;
                
                // Post the COMPLETE file content (no truncation of conflict chunks)
                if (content.length > 50000) {
                  // Split very large files into multiple comments
                  const chunks = [];
                  const chunkSize = 45000;
                  for (let i = 0; i < content.length; i += chunkSize) {
                    chunks.push(content.slice(i, i + chunkSize));
                  }
                  
                  console.log(`üì¶ Splitting into ${chunks.length} chunks`);
                  
                  for (let i = 0; i < chunks.length; i++) {
                    let body = '';
                    if (i === 0) {
                      body = header + `### Part ${i + 1} of ${chunks.length}\n\n`;
                    } else {
                      body = `### Part ${i + 1} of ${chunks.length} for \`${file}\`\n\n`;
                    }
                    
                    body += '```\n' + chunks[i] + '\n```\n\n';
                    
                    if (i === chunks.length - 1) {
                      body += '**Instructions:** Reply with a ```resolved:' + file + 
                              '``` code fence containing the COMPLETE fully resolved file with all conflicts merged correctly.';
                    }
                    
                    await github.rest.issues.createComment({ 
                      owner, repo, issue_number: prnum, body 
                    });
                  }
                } else {
                  // Single comment for normal files
                  const body = header +
                              '### Complete File Content with Conflicts\n\n' +
                              '```\n' + content + '\n```\n\n' +
                              '**Instructions:** Reply with a ```resolved:' + file + 
                              '``` code fence containing the COMPLETE fully resolved file with all conflicts merged correctly.';
                  
                  await github.rest.issues.createComment({ 
                    owner, repo, issue_number: prnum, body 
                  });
                  console.log(`‚úÖ Posted complete content for ${file}`);
                }
              } catch (e) {
                console.error(`‚ùå Failed to process ${file}:`, e);
                const body = `## üîß Conflict in: \`${file}\`\n\n` +
                            `ERROR: Could not read file content\n` +
                            `Error: ${e.message}\n\n` +
                            `${process.env.CODEX_HANDLE} - Please manually resolve this file.`;
                await github.rest.issues.createComment({ 
                  owner, repo, issue_number: prnum, body 
                });
              }
            }
            
            const summary = `## üìã Conflict Resolution Summary\n\n` +
                          `‚úÖ **Successfully detected ALL ${files.length} file(s) with merge conflicts:**\n\n` +
                          files.map(f => `- \`${f}\``).join('\n') + '\n\n' +
                          `${process.env.CODEX_HANDLE} - I have posted the COMPLETE content of each file above.\n` +
                          `Please provide \`\`\`resolved:<path>\`\`\` code fences to resolve them.\n\n` +
                          `The apply-ai-patches workflow will automatically apply your fixes.`;
            await github.rest.issues.createComment({ 
              owner, repo, issue_number: prnum, body: summary 
            });

  one-pr:
    if: github.event_name == 'issue_comment' &&
        github.event.issue.pull_request != null &&
        contains(github.event.comment.body, '/autofix')
    runs-on: ubuntu-latest
    # PR-specific concurrency to prevent workflow cancellation during conflict posting
    concurrency:
      group: autofix-pr-${{ github.event.issue.number }}
      cancel-in-progress: false
    steps:
      - name: Get PR info first
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo,
              pull_number: context.payload.issue.number
            });
            core.setOutput('number', pr.number);
            core.setOutput('ref', pr.head.ref);
            core.setOutput('repo', pr.head.repo.full_name);
            console.log(`Working on PR #${pr.number}, branch: ${pr.head.ref}`);

      - uses: actions/checkout@v4
        with: 
          repository: ${{ steps.pr.outputs.repo }}
          ref: ${{ steps.pr.outputs.ref }}
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Configure bot & fetch
        run: |
          git config user.name  "autorebase-bot"
          git config user.email "autorebase-bot@users.noreply.github.com"
          git config rerere.enabled true
          echo "Current branch: $(git branch --show-current)"
          git fetch origin main

      - name: Rebase
        run: |
          echo "Rebasing $(git branch --show-current) onto origin/main"
          git rebase origin/main || true

      - name: Autofix common conflicts (same as above)
        run: |
          python - <<'PY'
          import re, subprocess, pathlib
          sh=lambda c: subprocess.run(c, shell=True, check=False, capture_output=True, text=True)
          fixed_files = []
          
          # Get list of conflicted files first
          result = sh("git ls-files -u | cut -f2 | sort -u")
          initial_conflicts = result.stdout.strip().split('\n') if result.stdout.strip() else []
          if initial_conflicts:
              print(f"Initial conflicts detected in {len(initial_conflicts)} file(s):")
              for f in initial_conflicts:
                  print(f"  - {f}")
          
          # Markdown: union (drop markers)
          for p in pathlib.Path('.').rglob('*.md'):
              t=p.read_text(errors='ignore')
              if '<<<<<<<' in t and '>>>>>>>' in t:
                  t=re.sub(r'^<<<<<<< .*?\n|^=======\n|^>>>>>>> .*?\n','',t,flags=re.M)
                  p.write_text(t); sh(f"git add {p}")
                  fixed_files.append(str(p))
                  print(f"AUTO-FIXED (markdown union): {p}")
          
          # Lockfiles: prefer ours
          for n in ['package-lock.json','yarn.lock','pnpm-lock.yaml','poetry.lock']:
              p=pathlib.Path(n)
              if p.exists() and str(p) in initial_conflicts: 
                  sh(f"git checkout --ours {n} && git add {n}")
                  fixed_files.append(n)
                  print(f"AUTO-FIXED (lockfile): {n}")
          
          # Python: union/dedupe imports, dedupe include_router blocks
          CON=re.compile(r"<<<<<<< .*?\n(.*?)\n=======\n(.*?)\n>>>>>>> .*?\n", re.S)
          def dedupe(xs):
              out=[]; seen=set()
              for x in xs:
                  if x not in seen:
                      out.append(x); seen.add(x)
              return out
          def merge(a,b):
              A=[l.rstrip() for l in a.strip().splitlines()]
              B=[l.rstrip() for l in b.strip().splitlines()]
              if ''.join(A)==''.join(B):
                  return '\n'.join(A)+'\n'
              if all(l.startswith(('import ','from ')) or l=='' for l in A+B):
                  imp=dedupe([*A,*B]); imp=[l for l in imp if l]; imp.sort()
                  return '\n'.join(imp)+'\n'
              if 'app.include_router' in '\n'.join([*A,*B]):
                  def blocks(L):
                      buf=[]; out=[]
                      for l in L+['']:
                          buf.append(l)
                          if l.strip().startswith(')') or l.strip()=='':
                              ch='\n'.join(buf).strip()
                              if 'app.include_router' in ch: out.append(ch)
                              buf=[]
                      return out
                  m=dedupe(blocks(A)+blocks(B))
                  if m: return '\n\n'.join(m)+'\n'
              if len(A)<=10 and len(B)<=10:
                  return '\n'.join(dedupe(A+B))+'\n'
              return None
          for p in pathlib.Path('.').rglob('*.py'):
              t=p.read_text(errors='ignore')
              if '<<<<<<<' in t and '>>>>>>>' in t:
                  def repl(m):
                      r=merge(m.group(1), m.group(2))
                      return m.group(0) if r is None else r
                  new=CON.sub(repl,t)
                  if new!=t:
                      p.write_text(new); sh(f"git add {p}")
                      fixed_files.append(str(p))
                      print(f"AUTO-FIXED (python imports/routers): {p}")
          
          # SQL: Simple endings like COMMIT; or ON CONFLICT DO NOTHING;
          for p in pathlib.Path('.').rglob('*.sql'):
              t=p.read_text(errors='ignore')
              if '<<<<<<<' in t and '>>>>>>>' in t:
                  # Check for simple ending conflicts
                  if 'COMMIT;' in t or 'ON CONFLICT DO NOTHING;' in t:
                      lines = t.splitlines()
                      new_lines = []
                      skip_until_end = False
                      for line in lines:
                          if line.startswith('<<<<<<<') and any(x in '\n'.join(lines[lines.index(line):lines.index(line)+10] if lines.index(line)+10 < len(lines) else lines[lines.index(line):]) for x in ['COMMIT;', 'ON CONFLICT DO NOTHING;']):
                              skip_until_end = True
                          elif line.startswith('>>>>>>>') and skip_until_end:
                              skip_until_end = False
                              # Add the statement back once
                              if 'COMMIT' in '\n'.join(lines[max(0,lines.index(line)-5):lines.index(line)]):
                                  new_lines.append('COMMIT;')
                              elif 'ON CONFLICT' in '\n'.join(lines[max(0,lines.index(line)-5):lines.index(line)]):
                                  new_lines.append('ON CONFLICT DO NOTHING;')
                          elif not skip_until_end and not line.startswith('======='):
                              new_lines.append(line)
                      
                      new_content = '\n'.join(new_lines)
                      if new_content != t:
                          p.write_text(new_content)
                          sh(f"git add {p}")
                          fixed_files.append(str(p))
                          print(f"AUTO-FIXED (SQL endings): {p}")
          
          if fixed_files:
              print(f"\n‚úÖ Auto-fixed {len(fixed_files)} file(s) automatically:")
              for f in fixed_files:
                  print(f"  - {f}")
          
          # Check what's still conflicted
          result = sh("git ls-files -u | cut -f2 | sort -u")
          remaining_conflicts = result.stdout.strip().split('\n') if result.stdout.strip() else []
          if remaining_conflicts and remaining_conflicts != ['']:
              print(f"\n‚ö†Ô∏è {len(remaining_conflicts)} file(s) still have conflicts and need AI resolution:")
              for f in remaining_conflicts:
                  print(f"  - {f}")
          PY

      - name: Continue rebase if possible
        run: git -c core.editor=true rebase --continue || true

      - name: Check remaining conflicts
        id: conf
        run: |
          git ls-files -u | cut -f2 | sort -u > /tmp/conflicts || true
          echo "Files still in conflict after autofix:"
          cat /tmp/conflicts || true
          echo "count=$(wc -l < /tmp/conflicts | tr -d ' ')" >> $GITHUB_OUTPUT

      - name: Format (normalize diffs)
        if: steps.conf.outputs.count == '0'
        run: |
          python -m pip install --upgrade pip >/dev/null 2>&1 || true
          pip install black isort >/dev/null 2>&1 || true
          isort . || true
          black . || true
          git add -A

      - name: Commit & push if clean
        if: steps.conf.outputs.count == '0'
        run: |
          if ! git diff --cached --quiet; then
            git commit -m "autofix: rebase + safe conflict resolves"
          fi
          git push --force-with-lease origin HEAD:${{ steps.pr.outputs.ref }}
          echo "‚úÖ All conflicts resolved! PR is ready to merge."

      - name: Post per-file conflicts with COMPLETE files (manual path)
        if: steps.conf.outputs.count != '0'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const files = fs.readFileSync('/tmp/conflicts','utf8').trim().split('\n').filter(Boolean);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prnum = Number(process.env.PR_NUMBER);
            
            console.log(`Posting conflicts for ${files.length} files to PR #${prnum}`);
            
            await github.rest.issues.addLabels({ 
              owner, repo, issue_number: prnum, 
              labels: ['codex','needs-merge-help','auto-conflict'] 
            }).catch(()=>{});
            
            console.log(`üîç Detected ${files.length} conflicted files: ${files.join(', ')}`);
            
            // Post COMPLETE file content for each conflicted file
            for (const file of files) {
              try {
                console.log(`üìñ Processing: ${file}`);
                let content = '';
                let readMethod = 'unknown';
                
                // Method 1: Try direct read first (works if file exists with markers)
                try {
                  content = fs.readFileSync(file, 'utf8');
                  readMethod = 'direct fs.readFileSync';
                  console.log(`‚úÖ Read via direct fs.readFileSync`);
                } catch (fsErr) {
                  console.log(`‚ö†Ô∏è Direct read failed: ${fsErr.message}`);
                  
                  // Method 2: Use cat command to force read
                  try {
                    content = execSync(`cat "${file}" 2>/dev/null || echo "FILE_NOT_FOUND"`, 
                                     { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                    if (content === 'FILE_NOT_FOUND\n') {
                      throw new Error('File not found via cat');
                    }
                    readMethod = 'cat command';
                    console.log(`‚úÖ Read via cat command`);
                  } catch (catErr) {
                    console.log(`‚ö†Ô∏è Cat failed: ${catErr.message}`);
                    
                    // Method 3: Try git show for working tree
                    try {
                      content = execSync(`git show ":${file}" 2>/dev/null || echo "GIT_SHOW_FAILED"`, 
                                       { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                      if (content === 'GIT_SHOW_FAILED\n') {
                        throw new Error('Git show failed');
                      }
                      readMethod = 'git show';
                      console.log(`‚úÖ Read via git show`);
                    } catch (gitErr) {
                      console.log(`‚ö†Ô∏è Git show failed: ${gitErr.message}`);
                      
                      // Method 4: Get diff as last resort
                      try {
                        const diff = execSync(`git diff "${file}"`, 
                                            { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 });
                        content = `[Could not read full file - showing diff]\n\n${diff}`;
                        readMethod = 'git diff (fallback)';
                        console.log(`‚ö†Ô∏è Using git diff as fallback`);
                      } catch (diffErr) {
                        content = `ERROR: Unable to read file using any method\nTried: direct read, cat, git show, git diff\nLast error: ${diffErr.message}`;
                        readMethod = 'all methods failed';
                        console.log(`‚ùå All read methods failed`);
                      }
                    }
                  }
                }
                
                const hasMarkers = content.includes('<<<<<<<') && content.includes('>>>>>>>');
                console.log(`üìä File size: ${content.length} bytes, has conflict markers: ${hasMarkers}, read method: ${readMethod}`);
                
                const header = `## üîß Conflict in: \`${file}\`\n\n` +
                              `${process.env.CODEX_HANDLE} - This file has merge conflicts that need resolution.\n` +
                              `Read method: ${readMethod}\n\n`;
                
                // Post the COMPLETE file content (no truncation of conflict chunks)
                if (content.length > 50000) {
                  // Split very large files into multiple comments
                  const chunks = [];
                  const chunkSize = 45000;
                  for (let i = 0; i < content.length; i += chunkSize) {
                    chunks.push(content.slice(i, i + chunkSize));
                  }
                  
                  console.log(`üì¶ Splitting into ${chunks.length} chunks`);
                  
                  for (let i = 0; i < chunks.length; i++) {
                    let body = '';
                    if (i === 0) {
                      body = header + `### Part ${i + 1} of ${chunks.length}\n\n`;
                    } else {
                      body = `### Part ${i + 1} of ${chunks.length} for \`${file}\`\n\n`;
                    }
                    
                    body += '```\n' + chunks[i] + '\n```\n\n';
                    
                    if (i === chunks.length - 1) {
                      body += '**Instructions:** Reply with a ```resolved:' + file + 
                              '``` code fence containing the COMPLETE fully resolved file with all conflicts merged correctly.';
                    }
                    
                    await github.rest.issues.createComment({ 
                      owner, repo, issue_number: prnum, body 
                    });
                  }
                } else {
                  // Single comment for normal files
                  const body = header +
                              '### Complete File Content with Conflicts\n\n' +
                              '```\n' + content + '\n```\n\n' +
                              '**Instructions:** Reply with a ```resolved:' + file + 
                              '``` code fence containing the COMPLETE fully resolved file with all conflicts merged correctly.';
                  
                  await github.rest.issues.createComment({ 
                    owner, repo, issue_number: prnum, body 
                  });
                  console.log(`‚úÖ Posted complete content for ${file}`);
                }
              } catch (e) {
                console.error(`‚ùå Failed to process ${file}:`, e);
                const body = `## üîß Conflict in: \`${file}\`\n\n` +
                            `ERROR: Could not read file content\n` +
                            `Error: ${e.message}\n\n` +
                            `${process.env.CODEX_HANDLE} - Please manually resolve this file.`;
                await github.rest.issues.createComment({ 
                  owner, repo, issue_number: prnum, body 
                });
              }
            }
            
            const summary = `## üìã Conflict Resolution Summary\n\n` +
                          `‚úÖ **Successfully detected ALL ${files.length} file(s) with merge conflicts:**\n\n` +
                          files.map(f => `- \`${f}\``).join('\n') + '\n\n' +
                          `${process.env.CODEX_HANDLE} - I have posted the COMPLETE content of each file above.\n` +
                          `Please provide \`\`\`resolved:<path>\`\`\` code fences to resolve them.\n\n` +
                          `The apply-ai-patches workflow will automatically apply your fixes.`;
            await github.rest.issues.createComment({ 
              owner, repo, issue_number: prnum, body: summary 
            });